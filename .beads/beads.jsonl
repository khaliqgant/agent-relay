{"id":"bd-log1","title":"Add DIY minimal logging to agent-relay daemon","description":"Implement a lightweight ~20-line logging approach for the agent-relay daemon. No external library needed.\n\nRequirements:\n- log_info(), log_warn(), log_error(), log_debug() functions\n- JSON output format for easy parsing with jq\n- Configurable via LOG_FILE and DEBUG env vars\n- Log daemon startup/shutdown\n- Log errors (delivery failures, connection issues)\n- Debug-only message delivery logging\n- Minimal performance impact (sub-5ms system)\n\nImplementation:\n```bash\n_log() {\n    local level=\"$1\" msg=\"$2\"\n    local ts=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\n    printf '{\"ts\":\"%s\",\"level\":\"%s\",\"msg\":\"%s\"}\\n' \"$ts\" \"$level\" \"$msg\" >> \"$LOG_FILE\"\n    [[ \"$LOG_STDOUT\" == \"1\" ]] && echo \"[$level] $msg\"\n}\n\nlog_info()  { _log \"INFO\"  \"$1\"; }\nlog_warn()  { _log \"WARN\"  \"$1\"; }\nlog_error() { _log \"ERROR\" \"$1\"; }\nlog_debug() { [[ \"${DEBUG:-0}\" == \"1\" ]] && _log \"DEBUG\" \"$1\"; }\n```\n\nFiles modified:\n- src/utils/logger.ts (new file - TypeScript implementation)\n- src/daemon/server.ts (integrated logging)\n- src/utils/index.ts (exported logger)","priority":50,"status":"closed","created_at":"2026-01-01T07:40:00Z","closed_at":"2026-01-01T07:46:00Z","closed_reason":"Implemented TypeScript version with JSON output, configurable log levels, file logging support","tags":["logging","infrastructure","low-priority"]}
{"id":"bd-tmux-sched1","title":"Self-scheduling system for autonomous agent operation","description":"Inspired by Tmux-Orchestrator's schedule_with_note.sh, implement agent self-scheduling for 24/7 autonomous operation.\n\n## Problem\nAgents can't schedule their own check-ins. Users must manually trigger agents or use external cron jobs.\n\n## Solution\nNew relay command pattern:\n```\n->relay:schedule TIME MESSAGE [CONTEXT]\n```\n\nExamples:\n```\n->relay:schedule 30m \"Check PR review status\"\n->relay:schedule 2h \"Run integration tests\" --context=\"After deploy completes\"\n->relay:schedule 10m \"Resume task\" --continuity  # Auto-inject continuity context\n```\n\n## Implementation\n\n### 1. Parser (src/wrapper/parser.ts)\nAdd schedule pattern detection:\n```typescript\ninterface ScheduleCommand {\n  delay: number; // milliseconds\n  message: string;\n  context?: string;\n  injectContinuity?: boolean;\n}\n```\n\n### 2. Scheduler Service (src/daemon/scheduler.ts)\n```typescript\ninterface ScheduledMessage {\n  id: string;\n  agentName: string;\n  fireAt: Date;\n  message: string;\n  context?: string;\n  injectContinuity: boolean;\n  createdAt: Date;\n}\n\nclass SchedulerService {\n  // Store in SQLite for persistence across daemon restarts\n  async schedule(msg: ScheduledMessage): Promise<string>;\n  async cancel(id: string): Promise<boolean>;\n  async listPending(agentName?: string): Promise<ScheduledMessage[]>;\n  private startTimer(): void; // Check every minute\n  private async fireSchedule(schedule: ScheduledMessage): Promise<void>;\n}\n```\n\n### 3. Integration with Continuity\nWhen `--continuity` flag is set, auto-inject:\n- Current ledger state\n- Last handoff summary\n- Key decisions\n\n### 4. Dashboard Display\n- Show upcoming schedules per agent\n- Allow manual cancellation\n- Visual timeline of scheduled messages\n\n### 5. Persistence\n- SQLite table: scheduled_messages\n- Survives daemon restarts\n- Cleanup completed schedules after 24h\n\n## Files to Modify\n- src/wrapper/parser.ts - Add schedule pattern\n- src/daemon/scheduler.ts - New scheduler service\n- src/daemon/server.ts - Integrate scheduler\n- src/continuity/manager.ts - Add context injection helper\n- dashboard/src/components/SchedulePanel.tsx - UI component\n\n## Acceptance Criteria\n- [ ] Agents can schedule messages with `->relay:schedule`\n- [ ] Schedules persist across daemon restarts\n- [ ] Dashboard shows pending schedules\n- [ ] Optional continuity context injection\n- [ ] Cancel schedules via dashboard or command","priority":10,"status":"open","created_at":"2026-01-04T09:00:00Z","tags":["tmux-orchestrator","autonomy","scheduling","P0"]}
{"id":"bd-tmux-git1","title":"Git commit tracking and enforcement","description":"Inspired by Tmux-Orchestrator's 30-minute commit rule, track git activity and surface warnings.\n\n## Problem\nAgents work for hours without committing, risking data loss on crashes. No visibility into git discipline.\n\n## Solution\nTrack last commit time per agent, show warnings in dashboard, optionally block task assignment.\n\n## Implementation\n\n### 1. Git Activity Monitor (src/daemon/git-monitor.ts)\n```typescript\ninterface GitActivity {\n  agentName: string;\n  workspacePath: string;\n  lastCommitTime: Date | null;\n  lastCommitHash: string | null;\n  uncommittedChanges: boolean;\n  branchName: string;\n}\n\nclass GitMonitor {\n  // Poll git status periodically (every 5 min)\n  async checkStatus(workspacePath: string): Promise<GitActivity>;\n  async getAgentActivity(agentName: string): Promise<GitActivity | null>;\n}\n```\n\n### 2. Dashboard Integration\n- Show per-agent: \"Last commit: 45m ago\" with color coding\n  - Green: < 30 min\n  - Yellow: 30-60 min\n  - Red: > 60 min\n- Warning badge on agent card if overdue\n- Tooltip shows uncommitted file count\n\n### 3. Commit Reminder Messages\nOptional: Auto-send reminder to agent:\n```\n[GIT REMINDER] It's been 45 minutes since your last commit. Please commit your changes.\n```\n\n### 4. Configuration\n```yaml\n# .relay/config.yaml\ngit:\n  trackCommits: true\n  warnAfterMinutes: 30\n  reminderEnabled: true\n  reminderIntervalMinutes: 15\n```\n\n### 5. Enforcement Mode (Optional)\n- Block new task assignment if > 60 min since commit\n- Require explicit override: `->relay:override-commit-check`\n\n## Files to Modify\n- src/daemon/git-monitor.ts - New service\n- src/daemon/orchestrator.ts - Integrate git monitoring\n- src/daemon/types.ts - Add GitActivity type\n- dashboard/src/components/AgentCard.tsx - Show commit status\n- dashboard/src/components/GitStatus.tsx - New component\n\n## Acceptance Criteria\n- [ ] Track last commit time per agent workspace\n- [ ] Dashboard shows commit age with color coding\n- [ ] Optional commit reminder messages\n- [ ] Configurable thresholds\n- [ ] Works with standard git repositories","priority":15,"status":"open","created_at":"2026-01-04T09:00:00Z","tags":["tmux-orchestrator","git","discipline","P0"]}
{"id":"bd-tmux-ctx1","title":"Enhanced spawn with context notes","description":"Inspired by Tmux-Orchestrator's specification-driven approach, add structured context to spawn.\n\n## Problem\nSpawning agents with raw messages loses important context (specs, constraints, success criteria).\n\n## Solution\nEnhanced spawn syntax with structured context blocks.\n\n## Current\n```\n->relay:spawn Worker claude \"Implement login endpoint\"\n```\n\n## Proposed\n```\n->relay:spawn Worker claude <<<\nTASK: Implement /api/login endpoint\n\nCONTEXT:\n- Using JWT for authentication\n- See src/auth/utils.ts for helpers\n- Follow existing error handling patterns\n\nSPEC:\n- POST /api/login accepts {email, password}\n- Returns {token, refreshToken, expiresIn}\n- Rate limit: 5 attempts per minute\n\nCRITERIA:\n- All tests in tests/auth/login.test.ts pass\n- No security vulnerabilities\n- Response time < 200ms\n>>>\n```\n\n## Implementation\n\n### 1. Parser Enhancement (src/bridge/spawner.ts)\n```typescript\ninterface SpawnContext {\n  task: string;\n  context?: string[];\n  spec?: string[];\n  criteria?: string[];\n  files?: string[];\n  decisions?: string[];\n}\n```\n\n### 2. Context Injection\n- Parse structured blocks from spawn content\n- Inject as system message or prepend to task\n- Store in agent metadata for tracking\n\n### 3. Criteria Tracking\n- Store success criteria in agent record\n- Dashboard shows completion status\n- Agent can mark criteria as met: `->relay:criteria:done \"All tests pass\"`\n\n### 4. Template Support\n```\n->relay:spawn Worker claude --template=api-endpoint <<<\nendpoint: /api/login\nmethod: POST\nauth: required\n>>>\n```\n\n## Files to Modify\n- src/bridge/spawner.ts - Enhanced context parsing\n- src/wrapper/parser.ts - Structured block parser\n- src/daemon/agent-manager.ts - Store spawn context\n- dashboard/src/components/AgentDetail.tsx - Show context/criteria\n\n## Acceptance Criteria\n- [ ] Parse TASK/CONTEXT/SPEC/CRITERIA blocks from spawn\n- [ ] Store structured context in agent metadata\n- [ ] Display spawn context in dashboard\n- [ ] Optional template support for common patterns","priority":25,"status":"open","created_at":"2026-01-04T09:00:00Z","tags":["tmux-orchestrator","spawn","context","P1"]}
{"id":"bd-tmux-esc1","title":"Escalation rules engine","description":"Inspired by Tmux-Orchestrator's escalation patterns, add configurable escalation rules.\n\n## Problem\nNo automatic escalation when agents are blocked or conversations go in circles.\n\n## Solution\nConfigurable rules that auto-notify leads when thresholds are exceeded.\n\n## Implementation\n\n### 1. Rules Configuration (.relay/escalation.yaml)\n```yaml\nrules:\n  - name: stuck-conversation\n    trigger:\n      type: message_count\n      between: [\"Worker\", \"*\"]  # Any agent\n      threshold: 5\n      window: 10m\n    condition: no_resolution  # No DONE message\n    action:\n      notify: lead\n      message: \"Conversation between {agents} has exceeded {threshold} messages without resolution\"\n\n  - name: blocked-agent\n    trigger:\n      type: status\n      status: blocked\n      duration: 15m\n    action:\n      notify: lead\n      message: \"{agent} has been blocked for {duration}\"\n\n  - name: idle-with-work\n    trigger:\n      type: idle\n      duration: 30m\n      condition: has_pending_tasks\n    action:\n      notify: lead\n      message: \"{agent} is idle with pending work\"\n```\n\n### 2. Escalation Service (src/daemon/escalation.ts)\n```typescript\ninterface EscalationRule {\n  name: string;\n  trigger: EscalationTrigger;\n  condition?: string;\n  action: EscalationAction;\n}\n\nclass EscalationService {\n  private rules: EscalationRule[];\n  async checkRules(): Promise<void>;\n  async notifyLead(agentName: string, message: string): Promise<void>;\n}\n```\n\n### 3. Dashboard Alerts\n- Show escalation alerts prominently\n- History of escalations\n- Manual resolve button\n\n### 4. Default Rules\n- 5 messages without DONE → notify lead\n- Blocked > 15 min → notify lead\n- Idle with pending work > 30 min → notify lead\n\n## Files to Modify\n- src/daemon/escalation.ts - New service\n- src/daemon/orchestrator.ts - Integrate escalation\n- dashboard/src/components/AlertPanel.tsx - Show escalations\n\n## Acceptance Criteria\n- [ ] Configurable escalation rules in YAML\n- [ ] Auto-detect stuck conversations\n- [ ] Auto-detect blocked/idle agents\n- [ ] Notify lead agent when rules trigger\n- [ ] Dashboard shows escalation history","priority":30,"status":"open","created_at":"2026-01-04T09:00:00Z","tags":["tmux-orchestrator","escalation","monitoring","P1"]}
{"id":"bd-tmux-learn1","title":"Shared learning repository","description":"Inspired by Tmux-Orchestrator's LEARNINGS.md pattern, create a shared knowledge base.\n\n## Problem\nLearnings captured in individual handoffs aren't easily discoverable across agents.\n\n## Solution\nShared learning repository with learn/recall commands.\n\n## Commands\n```\n->relay:learn \"JWT refresh tokens should use 7-day expiry for mobile apps\"\n->relay:learn --category=auth \"Always validate token expiry on server side\"\n\n->relay:recall \"JWT best practices\"\n->relay:recall --category=auth\n->relay:recall --recent=10\n```\n\n## Implementation\n\n### 1. Learning Store (src/continuity/learning-store.ts)\n```typescript\ninterface Learning {\n  id: string;\n  content: string;\n  category?: string;\n  agentName: string;\n  createdAt: Date;\n  usefulCount: number;  // Incremented when recalled\n  relatedFiles?: string[];\n  trajectory?: string;  // Source trajectory ID\n}\n\nclass LearningStore {\n  async add(learning: Omit<Learning, 'id' | 'createdAt' | 'usefulCount'>): Promise<string>;\n  async search(query: string, options?: SearchOptions): Promise<Learning[]>;\n  async listByCategory(category: string): Promise<Learning[]>;\n  async markUseful(id: string): Promise<void>;\n}\n```\n\n### 2. Auto-Extraction from Trajectories\nWhen trajectory completes with learnings field, auto-add to repository.\n\n### 3. Semantic Search (Optional Enhancement)\n- Use embeddings for similarity search\n- Fallback to keyword matching\n\n### 4. Dashboard Panel\n- Browse all learnings\n- Filter by category, agent, date\n- Most useful learnings (by recall count)\n\n### 5. Cross-Project Sharing\nIn bridge mode, learnings can be shared across projects.\n\n## Files to Modify\n- src/continuity/learning-store.ts - New store\n- src/continuity/manager.ts - Integrate learning store\n- src/wrapper/parser.ts - Add learn/recall patterns\n- src/trajectory/integration.ts - Auto-extract learnings\n- dashboard/src/components/LearningsPanel.tsx - Browse UI\n\n## Acceptance Criteria\n- [ ] Agents can add learnings with `->relay:learn`\n- [ ] Agents can search learnings with `->relay:recall`\n- [ ] Learnings persist in SQLite\n- [ ] Dashboard shows searchable learning repository\n- [ ] Auto-extract from completed trajectories\n- [ ] Track which learnings are most useful","priority":40,"status":"open","created_at":"2026-01-04T09:00:00Z","tags":["tmux-orchestrator","learning","knowledge-base","P2"]}
